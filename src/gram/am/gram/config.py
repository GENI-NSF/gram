#----------------------------------------------------------------------
# Copyright (c) 2013 Raytheon BBN Technologies
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and/or hardware specification (the "Work") to
# deal in the Work without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Work, and to permit persons to whom the Work
# is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Work.
#
# THE WORK IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE WORK OR THE USE OR OTHER DEALINGS
# IN THE WORK.
#----------------------------------------------------------------------

# This file contains a set of parameters 
# To be accessed as "config.X" for a parameter X
# The values in this file are defaults: they are
# to be overriden by changing the /etc/gram/config.json file
#
# Do not edit this file for configuring a specific GRAM installation

# Note: Variables with None initial values have no default and MUST be set
# in the configuration file


import logging
import socket
import sys
import gmoc.gmoc

# GRAM aggregate manager ports for V2 and V3
gram_am_port = 5001
gram_am_v2_port = 5002

# OpenStack related configuration
default_VM_flavor = 'm1.small'  
default_OS_image = 'ubuntu-12.04'
default_OS_type = 'Linux'
default_OS_version = '12'

# Name of external router
external_router_name = 'externalRouter'

tenant_admin_pwd = 'sliceMaster:-)'  # Password for the tenant's admin user
                                  # account


# GENI interface related configuration
default_execute_shell = 'sh'   # default shell to use for use by execute
                               # services specified in the request rspec
urn_prefix = 'urn:publicid:IDN+' + socket.getfqdn() + '+'
sliver_urn_prefix = urn_prefix + 'sliver+'
vm_urn_prefix = sliver_urn_prefix + 'vm'
interface_urn_prefix = sliver_urn_prefix + 'interface'
link_urn_prefix = sliver_urn_prefix + 'link'
image_urn_prefix = urn_prefix + 'image'

allocation_expiration_minutes =  10      # allocations expire in 10 mins
lease_expiration_minutes =  7 * 24 * 60  # resources can be leased for 7 days

# Aggregate Manager software related configuration
logger = logging.getLogger('gcf.am3.gram')

# Parameters regarding archiving/restoration of GRAM aggregste state
gram_snapshot_directory = '/etc/gram/snapshots' # Directory of snapshots
recover_from_snapshot = "" # Specific file from which to recover 
recover_from_most_recent_snapshot = True # Should we restore from most recent
snapshot_maintain_limit = 10 # Remove all snapshots earlier than this #

# File where GRAM stores the subnet number for the last allocated sub-net
# This is used in resources.py.  This file is temporary.  It should not be
# needed when we have namespaces working.
subnet_numfile = '/etc/gram/GRAM-next-subnet.txt'

# File where GRAM stores the SSH proxy port state table, and its assoicated
# lock file. These files are used in manage_ssh_proxy.py
port_table_file = '/etc/gram/gram-ssh-port-table.txt'
port_table_lock_file = '/etc/gram/gram-ssh-port-table.lock'

# Location of the GRAM SSH proxy utility binary, which enables GRAM
# to create and delete proxies for each user requested VM
ssh_proxy_exe = '/usr/local/bin/gram_ssh_proxy'

# Start and ending port range values used by the GRAM SSH Proxies
ssh_proxy_start_port = 3000
ssh_proxy_end_port = 3999

# GRAM AM URN (Component ID of AM)
gram_am_urn = 'gram.gram'

# PORT on which to communicate to VMOC interface manager
vmoc_interface_port = 7001

# Should GRAM automatically register slices with VMOC?
vmoc_slice_autoregister = True # Set to False to disable GRAM/VMOC interface

# Variables for VMOC/GRAM switch behavior/configuration
vmoc_set_vlan_on_untagged_packet_out = False
vmoc_set_vlan_on_untagged_flow_mod = True
vmoc_accept_clear_all_flows_on_startup = True

# Maps disk_image by name to dic with {os, version, description}
disk_image_metadata = {}

# Backup directory for rolling back gram/openstack installation
backup_directory = "/home/gram/.backup"

# A set of parameters for configuring or documenting
# the OpenStack or underlying network Configuration

# Interface information for the 'external' (public IP) network
external_interface = None
external_address = None
external_netmask = None

# Interface information for the 'control' network
# (for OpenStack/Gram API control traffic
control_interface = None
control_address = None

# Interface for 'data' network
# This network is controlled by quantum and flows through
# The OF switch
data_interface = None
data_address = None

public_dns_nameservers = None

# Interface for 'management' network
# This is the network over which experimenters can SSH into VM's
management_interface = None
management_address = None

#### THIS SHOULD BE IN CONFIG.JSON
management_network_name = 'GRAM-mgmt-net'
management_network_cidr = '192.168.10.0/24' # GRAM AM assumes this is a /24 network
management_network_vlan = '2500'
mgmt_ns = ' '

# Parameters for establishing the 'public' Quantum network
public_gateway_ip = None
public_subnet_cidr = None
public_subnet_start_ip = None
public_subnet_end_ip = None

# Passwords and user names
mysql_user = None
mysql_password = None
rabbit_password = None
nova_user = "nova"
nova_password = None
glance_user = "glance"
glance_password = None
keystone_user = "keystone"
keystone_password = None
quantum_user = "quantum"
quantum_password = None
gmoc_user = "gram"
gmoc_password = ' '

# OpenStack user configuration 
os_tenant_name = None
os_username = None
os_password = None
os_auth_url = "http://localhost:5000/v2.0/"
os_region_name = "RegionOne"
os_no_cache = 1
service_token = None
service_endpoint = "http://localhost:35357/v2.0"

# TCP port over which metadata is transmitted
metadata_port = 8775

# Hostname of control node
control_host = None
control_host_addr = None

# List of compute node names and addresses
compute_hosts = None

# List of host names and addresses to put in /etc/hosts file
host_file_entries = None

# GMOC configuration variables
gmoc_url = ' '
gmoc_site_name = ' '
gmoc_org_name = ' '
gmoc_pop_name = ' '
gmoc_am_type = 'gram'
gmoc_debug_level = gmoc.GMOC_DEBUG_OFF




glance_images = None

# Stitching information for this aggregate. A JSON structure
# containing
# aggregate_id : The URN of this AM
# aggregate_url : The URL of this AM
# edge_points: a list of dictionaries
#    local_switch : URN of local switch
#    port : URN port on local switch leading to remote switch
#    remote_switch: URN of remote switch
#    vlans : VLAN tags configured on this port 
stitching_info = None

import json
import sys
# Read in configuration file
# For each key in JSON dictionary read
# Try to set the associated value in config module
# if it can be coerced into the object of current type
def initialize(config_file):
#    print "config.initialize: " + config_file

    data = None
    try:
        f = open(config_file, 'r')
        data = f.read()
        f.close()
    except Exception, e:
        print "Failed to read GRAM config file: " + config_file + str(e)
        logger.info("Failed to read GRAM config file: " + config_file)
        return

    config_module = sys.modules[__name__]
    data_json = json.loads(data)

    for var in data_json.keys():
        if var[:2] == "__": continue # Comment in the JSON file
#        print var + " " + str(data_json[var])
        if not hasattr(config_module, var):
            logger.info("No variable named " + var + " in module config")
        else:
            current_type = type(getattr(config_module, var)).__name__
            new_value = data_json[var]
            new_type = type(new_value).__name__
            can_coerce = True

#            print "CT = " + current_type + " NT = " + new_type + " NV = " + str(new_value)

            try :
                if current_type == "NoneType":
                    pass
                elif current_type == new_type:
                    pass
                elif current_type == 'int':
                    new_value = int(new_value)
                elif current_type == 'long':
                    new_value = long(new_value)
                elif current_type == 'str':
                    new_value = str(new_value)
                elif current_type == 'float':
                    new_value = float(new_value)
                elif current_type == 'bool':
                    new_value = bool(new_value)
                else:
                    logger.info("Can't coerce type " + current_type + " to " + 
                                new_type)
                    can_coerce = False
            except Exception, e:
                logger.info("Error coercing value : " + str(new_value) + \
                                "to " + current_type)
                can_coerce = False

            if can_coerce:
#                print "Setting " + var + " " + str(new_value)
                setattr(config_module, var, new_value)

    unset_required = []
    for param in dir(config_module):
        if param.startswith("__"): continue
        value = getattr(config_module, param)
        if value == None:
            unset_required.append(param)

    if len(unset_required) > 0:
        print "The following config parameters have no defaults and must be set:"
        for param in unset_required: print "   " + param
        sys.exit(0)

